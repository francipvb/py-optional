{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"py-optional","text":""},{"location":"#introduction","title":"Introduction","text":"<p>This is a python implementation for optional values. Don't confuse them with <code>None</code> values because in fact thei are present.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Supports setting values as empty.</li> <li>Implements checks for value presence or absence.</li> <li>Factory methods to create empty and valued objects are provided.</li> <li>Full typing support.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Install the latest release:</p> <pre><code>pip install py-optional\n</code></pre> <p>Or you can clone <code>py-optional</code> and get started locally</p> <pre><code># ensure you have Poetry installed\npip install --user poetry\n\n# install all dependencies (including dev)\npoetry install\n\n# develop!\n</code></pre>"},{"location":"#example-usage","title":"Example Usage","text":"<pre><code># Import it with an alias\nfrom optional import Optional as O, Of, Empty\n\n# This is the main purpose of the library, so define a function\ndef sum_numbers(*, a: O[int] = Empty(), b: O[int] = Empty()):\n    # Check if the two numbers are empty:\n    if a.is_empty and b.is_empty:\n        raise ValueError('No numbers were provided.')\n\n    # The `or_else` method returns either the default value or the wrapped value:\n    return a.or_else(0) + b.or_else(0)\n\n# Sum an int with nothing:\nprint(sum_numbers(a=Of(3), b=Of(5))) # -&gt; 8\n</code></pre> <p>Only Python 3.8+ is supported.</p> <p>When you make a release on GitHub, the publish workflow will run and deploy to PyPi! \ud83d\ude80\ud83c\udf89\ud83d\ude0e</p>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"CHANGELOG/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/#130-2024-06-02","title":"[1.3.0] - 2024-06-02","text":""},{"location":"CHANGELOG/#new-features","title":"New features","text":"<ul> <li>Made internal <code>Empty</code> and <code>Of</code> classes public.</li> </ul>"},{"location":"CHANGELOG/#cicd","title":"CI/CD","text":"<ul> <li>Improved testing on CI.</li> </ul>"},{"location":"CHANGELOG/#internal","title":"Internal","text":"<ul> <li>Upgraded dependencies.</li> </ul>"},{"location":"CHANGELOG/#110-2023-09-22","title":"1.1.0 - 2023-09-22","text":""},{"location":"CHANGELOG/#new-features_1","title":"New features","text":"<ul> <li>Added an optional property decorator. See usage document for details.</li> </ul>"},{"location":"CHANGELOG/#10a6-2023-04-24","title":"1.0a6 - 2023-04-24","text":"<ul> <li>Changed build documentation step display name.</li> </ul>"},{"location":"CHANGELOG/#10a5-2023-04-24","title":"1.0a5 - 2023-04-24","text":"<ul> <li>Changed publish workflow to use gh-deploy command.</li> </ul>"},{"location":"CHANGELOG/#10a4-2023-04-24","title":"1.0a4 - 2023-04-24","text":"<ul> <li>Fixed publish workflow to publish on tags insthead of github releases.</li> </ul>"},{"location":"CHANGELOG/#10a3-2023-04-24","title":"1.0a3 - 2023-04-24","text":""},{"location":"CHANGELOG/#fixes","title":"Fixes","text":"<ul> <li>Fixed publishing workflow to set the version before building the package.</li> </ul>"},{"location":"CHANGELOG/#10a2-2023-04-24","title":"1.0a2 - 2023-04-24","text":"<p>Hotfix release, fixing publish workflow.</p>"},{"location":"CHANGELOG/#10a1-2023-04-24","title":"1.0a1 - 2023-04-24","text":"<p>This is the initial release.</p>"},{"location":"CHANGELOG/#features","title":"Features","text":"<ul> <li>Added Optional object.</li> <li>Added tests to reach 100% coverage.</li> </ul>"},{"location":"CHANGELOG/#documentation","title":"Documentation","text":"<ul> <li>Added basic documentation.</li> </ul>"},{"location":"MOTIVATION/","title":"Motivation","text":"<p>TLDR:</p> <p>This is inspired by java Option object and dart optional package.</p>"},{"location":"MOTIVATION/#objective","title":"Objective","text":"<p>When writing updateable resources, sometimes you only want a subset of the data to be changed. This is not an issue if the data shouldn't be <code>None</code> value. However, there are cases when the data can be <code>None</code> and you must ensure the value were not provided.</p> <p>You can, of course, use a sentinel object as function's default values, but then you are issues with the typing support.</p> <p>This is why I coded this simple, trivial construction for the python community.</p>"},{"location":"USAGE/","title":"Detailed usage instructions","text":""},{"location":"USAGE/#importing","title":"Importing","text":"<p>If you use the typing support for python, you know about the <code>Optional</code> python type marker. For this reason, you may encounter issues when using this library.</p> <p>To avoid this issue, you can import the class with an alias for disambiguation:</p> Example importing<pre><code>from optional import Optional as O\n</code></pre>"},{"location":"USAGE/#empty-values","title":"Empty values","text":"<p>Main purpose for empty values are to be supplied as default function parameter values, like the below example:</p> <pre><code>from typing import Dict, Any\n\nfrom optional import Optional as O, Empty\n\ndef test_function(\n    *,\n    value1: O[int] = Empty(),\n    value2: O[float] = Empty(),\n) -&gt; Dict[str, Any]:\n    data = {}\n    if value1.has_value:\n        data.update(value1=value1.value)\n\n    if value_2.has_value:\n        data.update(value2=value2.value)\n\n    return data\n</code></pre> <p>In the previous example, if you provide a value for any predefined parameter, you'll get it inserted in the dict, even if it is set to None.</p>"},{"location":"USAGE/#optional-values","title":"Optional values","text":"<p>An <code>Optional</code> object, if not empty, wraps a value. The value can be anything, including <code>None</code> values.</p> <p>For example, if you want to call the function we've defined above, we do something like this:</p> <pre><code>from Optional import Of\n\n\ntest_func(value1=Of(2)) # {'value1': 2}\n</code></pre>"},{"location":"USAGE/#the-or_else-method","title":"The <code>or_else</code> method","text":"<p>Sometimes you need a value to call a function. For this situation there is the or_else method.</p> <p>This method returns another Optional object with these differences:</p> <ul> <li>If the source object has a value, this value is returned.</li> <li>if the source is an optional.Empty object, the value property returns the supplied value.</li> <li>The has_value property always returns <code>True</code>.</li> </ul> <p>For example:</p> <pre><code>&gt;&gt;&gt; from optional import Optional as Empty, Of\n&gt;&gt;&gt; Empty().or_else(45).value\n45\n&gt;&gt;&gt; Of(33).or_else(45).value\n33\n&gt;&gt;&gt;\n</code></pre>"},{"location":"USAGE/#the-map-method","title":"The <code>map</code> method","text":"<p>Another functionality of the Optional objects is the map method. Again, this method returns a new Optional object with custom behavior:</p> <ul> <li>The <code>has_value</code> and <code>is_empty</code> reflects the values of the source Optional object.</li> <li>The <code>value</code> object runs a function, providing the result of the source <code>value</code> property.</li> </ul> <p>The implications of the last point is that you can chain <code>map</code> method calls to subsequently transform the value, and the callable won't run until you access the <code>value</code> property. However, if any of the source Optional objects is empty, you'll get an exception raised.</p> <p>To prevent this, you can call the <code>or_else</code> method on the new Optional object.</p>"},{"location":"USAGE/#the-apply-and-apply_async-methods","title":"The <code>apply</code> and <code>apply_async</code> methods","text":"<p>These methods have a similar purpose. The only difference is that the <code>apply_async</code> method should be called when an async operation should be done for the Optional value.</p>"},{"location":"USAGE/#the-optionalproperty-decorator","title":"The optionalproperty decorator","text":"<p>This decorator returns an OptionalProperty object.</p> <p>The OptionalProperty class is a descriptor emulating a property with a default value. If a value is not set, a callable is executed to provide the default value.</p> <p>The descriptor also has a method to check wether the value is set in a specific object instance.</p> <p>This functionality is powered by the Optional objects.</p> <p>See the optional property decorator and class documentation for details.</p>"},{"location":"api/","title":"API reference","text":""},{"location":"api/#optional.NullableOptional","title":"<code>NullableOptional = typing.Union[Optional[_T], Optional[None]]</code>  <code>module-attribute</code>","text":"<p>A nullable optional.</p> <p>This is just an alias to <code>typing.Union[Optional[_T], Optional[None]]</code>.</p>"},{"location":"api/#optional.Empty","title":"<code>Empty</code>","text":"<p>               Bases: <code>Optional[Any]</code></p> <p>Represents an optional empty value.</p> <p>This is ideal to put in function argument default values as this object does not hold any data and therefore is not mutable.</p> <p>Usage example:</p> <pre><code>from optional import Optional, Empty, Of\n\n\ndef multiply(optional_value: Optional[int]=Empty(), multiplier: Optional[int]=Empty()) -&gt; int:\n    return optional_value.or_else(2).value * multiplier.or_else(2).value\n</code></pre>"},{"location":"api/#optional.Of","title":"<code>Of</code>","text":"<p>               Bases: <code>Optional[_T]</code>, <code>Generic[_T]</code></p> <p>An optional value wrapper.</p> <p>This is an optional value wrapping a concrete value.</p> <p>Example usage: <pre><code>from optional import Optional, Empty, Of\n\ndef update_something(entity_id: int, *, name: Optional[str]=Empty())-&gt;bool:\n    if name:\n        print(f\"Setting name to {name.value}\")\n        return True\n    return False\n\nupdate_something(1, name=Of(\"Karl\"))\n</code></pre></p> <p>Note that this is not like the python <code>None</code> value. This can hold <code>None</code> values too</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>_T</code> <p>The value to wrap</p> required"},{"location":"api/#optional.Optional","title":"<code>Optional</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[_T]</code></p> <p>Represents an optional value.</p> <p>See the of and empty classes.</p>"},{"location":"api/#optional.Optional.has_value","title":"<code>has_value: bool</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get wether this object has a value in it.</p> <p>If the value is not present, an exception is raised.</p> <p>Returns:</p> Name Type Description <code>True</code> <code>bool</code> <p>If the value is present</p> <code>False</code> <code>bool</code> <p>If the Optional object is empty</p>"},{"location":"api/#optional.Optional.is_empty","title":"<code>is_empty: bool</code>  <code>property</code>","text":"<p>Get wether this instance is empty</p> <p>This just returns the opposite of has_value.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the value is not present, <code>False</code> otherwise</p>"},{"location":"api/#optional.Optional.value","title":"<code>value: _T</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the wrapped value.</p> <p>Raises:</p> Type Description <code>ValueNotProvidedError</code> <p>If the value were not provided</p> <p>Returns:</p> Name Type Description <code>_T</code> <code>_T</code> <p>The wrapped value</p>"},{"location":"api/#optional.Optional.apply","title":"<code>apply(func, *, if_empty=None)</code>","text":"<p>Call a function if the value is present.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[_T], None]</code> <p>The code to call if the value is present</p> required <code>if_empty</code> <code>Union[Callable[[], None], None]</code> <p>The function to be called if the value is not present.</p> <code>None</code>"},{"location":"api/#optional.Optional.apply_async","title":"<code>apply_async(func, *, if_empty=None)</code>  <code>async</code>","text":"<p>Call an async function if the value is present.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[_T], Awaitable[None]]</code> <p>The async function to call</p> required <code>if_empty</code> <code>Union[Callable[[], Awaitable[None]], None]</code> <p>The function to be called if the value is not present.</p> <code>None</code>"},{"location":"api/#optional.Optional.empty","title":"<code>empty()</code>  <code>staticmethod</code>","text":"<p>Build an empty Optional object.</p> <p>This method is deprecated. Use Empty class directly.</p> <p>Returns:</p> Type Description <code>Optional[Any]</code> <p>An empty optional instance</p>"},{"location":"api/#optional.Optional.map","title":"<code>map(mapper)</code>","text":"<p>Build a value mapper.</p> <p>The returned value is another Optional implementation that runs the mapper function.</p> <p>The provided callable is run once for every instance and after the value has been mapped it is cached on the object.</p> <p>For example:</p> <pre><code>&gt;&gt;&gt; from optional import Optional\n&gt;&gt;&gt; opt=Optional.of(33).map(lambda x: x*2)\n&gt;&gt;&gt; opt.value\n66\n&gt;&gt;&gt;\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>mapper</code> <code>Callable[[_T], _TR]</code> <p>The mapper function</p> required <p>Returns:</p> Type Description <code>Optional[_TR]</code> <p>A new Optional object</p>"},{"location":"api/#optional.Optional.of","title":"<code>of(value)</code>  <code>staticmethod</code>","text":"<p>Build an Optional object.</p> <p>This method is deprecated. Use Of class directly.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to wrap</p> required <p>Returns:</p> Type Description <code>Optional[Any]</code> <p>The [Optional] wrapper.</p>"},{"location":"api/#optional.Optional.or_else","title":"<code>or_else(value)</code>","text":"<p>Return an optional value wrapping this.</p> <p>If this optional has a value, the value is returned. Otherwise, the supplied value is returned from the returned object's value property.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>_T</code> <p>The value to retrieve if the instance is empty</p> required <p>Returns:</p> Type Description <code>Optional[_T]</code> <p>The Optional object wrapping this</p>"},{"location":"api/#optional.OptionalProperty","title":"<code>OptionalProperty</code>","text":"<p>               Bases: <code>Generic[_V]</code></p> <p>An optional property.</p> <p>This construct holds a value only if was set. Otherwise, a callable object supplies the default value.</p> Example usage <pre><code>&gt;&gt;&gt; from optional import OptionalProperty\n\n&gt;&gt;&gt; class Foo:\n...     @OptionalProperty\n...     def my_property(self):\n...         return \"default\"\n\n&gt;&gt;&gt; obj=Foo()\n&gt;&gt;&gt; # Get the default value\n&gt;&gt;&gt; obj.my_property\n'default'\n&gt;&gt;&gt; # Check wether the value is present\n&gt;&gt;&gt; Foo.my_property.is_present(obj)\nFalse\n&gt;&gt;&gt; # Set another value and retrieve it\n&gt;&gt;&gt; obj.my_property=\"other\"\n&gt;&gt;&gt; obj.my_property\n'other'\n&gt;&gt;&gt; Foo.my_property.is_present(obj)\nTrue\n&gt;&gt;&gt; # Just use python syntax to restore to the default value\n&gt;&gt;&gt; del obj.my_property\n&gt;&gt;&gt; obj.my_property\n'default'\n</code></pre> <p>The type parameter <code>_V</code> if the type accepted and returned by the property.</p>"},{"location":"api/#optional.OptionalProperty.is_present","title":"<code>is_present(obj)</code>","text":"<p>Check wether the property was set.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>The object to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the property was set. Otherwise returns <code>False</code></p>"},{"location":"api/#optional.OptionalProperty.raw","title":"<code>raw(obj)</code>","text":"<p>Retrieve the raw optional object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>Theobject to check</p> required <p>Returns:</p> Type Description <code>Optional[_V]</code> <p>The raw optional object powering the property.</p>"},{"location":"api/#optional.ValueNotProvidedError","title":"<code>ValueNotProvidedError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised if a value were not provided to an optional object.</p>"},{"location":"api/#optional.optionalproperty","title":"<code>optionalproperty(func)</code>","text":"<p>Alias for OptionalProperty.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[Any], _V]</code> <p>The default value supplier.</p> required <p>Returns:</p> Type Description <code>OptionalProperty[_V]</code> <p>An optional property construct.</p>"}]}